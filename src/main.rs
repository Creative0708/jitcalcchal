#[cfg(not(all(unix, target_arch = "x86_64")))]
compile_error!("This toy JIT compiler only works on x86-64 Linux. Sorry!");

fn main() {
    let arg = std::env::args().nth(1);
    let program = match arg {
        None => {
            eprintln!("usage:");
            eprintln!("\tjitcalcchal <program>");
            return;
        }
        Some(program) => program,
    };

    let machine_code = jit(&program);
    let result = unsafe { run(&machine_code) };
    println!(
        "The program \"{}\" calculates the value {}",
        program, result
    );
}

// Parses a calculator "program" and returns a sequence of bytes
// corresponding to the equivalent machine code
fn jit(program: &str) -> Vec<u8> {
    let mut output_vec: Vec<u8> = Vec::new();

    // Instruction encodings generated by the NASM file (check out /nasm/opcodes.asm for details)

    output_vec.extend(b"\x48\x31\xc0");

    for token in program.chars() {
        let bytes: &[u8] = match token {
            '+' => b"\x48\xff\xc0",
            '-' => b"\x48\xff\xc8",
            '*' => b"\x48\xd1\xe0",
            '/' => b"\x48\x89\xc3\x48\xc1\xe8\x3f\x48\x01\xd8\x48\xd1\xf8",
            _ => continue,
        };
        output_vec.extend(bytes);
    }

    output_vec.extend(b"\xc3");

    output_vec
}

// Runs the machine code (provided as a byte slice) and returns the resulting value
//
/// # Safety
///
/// `machine_code` must be valid machine code in the C ABI that returns an `i64`.
unsafe fn run(machine_code: &[u8]) -> i64 {
    fn perror(func: &str) -> ! {
        panic!("error in {func}: {}", std::io::Error::last_os_error());
    }

    use core::{ffi::c_void, mem, ptr, slice};
    const PAGE_SIZE: usize = 4096;
    let mmap_len = machine_code.len().div_ceil(PAGE_SIZE) * PAGE_SIZE;

    // SAFETY: We're making an anonymous mapping here (of length mmap_len)
    // See mmap(2) for details
    let mmap_ptr = unsafe {
        libc::mmap(
            ptr::null_mut(),
            mmap_len,
            libc::PROT_WRITE | libc::PROT_READ,
            libc::MAP_PRIVATE | libc::MAP_ANONYMOUS,
            -1,
            0,
        )
    };
    if mmap_ptr == libc::MAP_FAILED {
        perror("mmap");
    }
    {
        // SAFETY: mmap_ptr is a valid ptr of length mmap_len and is valid until the end of this block
        let map_slice = unsafe { slice::from_raw_parts_mut(mmap_ptr.cast::<u8>(), mmap_len) };
        map_slice[0..machine_code.len()].copy_from_slice(machine_code);
    }

    // Make the memory readonly but executable for security (W^X) https://en.wikipedia.org/wiki/W%5EX
    // SAFETY: mmap_ptr is a valid ptr of length mmap_len
    // See mprotect(2) for details
    let mprotect_res =
        unsafe { libc::mprotect(mmap_ptr, mmap_len, libc::PROT_EXEC | libc::PROT_READ) };
    if mprotect_res < 0 {
        perror("mprotect");
    }

    // Cast to a C function pointer and call it
    let result = {
        // SAFETY: now having written machine_code to mmap_ptr and made it executable, mmap_ptr is now a valid C function.
        let func = unsafe { mem::transmute::<*mut c_void, extern "C" fn() -> i64>(mmap_ptr) };

        func()
    };

    // Free the memory!
    // SAFETY: mmap_ptr is a valid ptr of length mmap_len
    let munmap_res = unsafe { libc::munmap(mmap_ptr, mmap_len) };
    if munmap_res < 0 {
        perror("munmap");
    }

    result
}

#[cfg(test)]
mod tests {
    use super::{jit, run};

    #[test]
    fn test_programs() {
        fn pair(program: &str, expected: i64) {
            let machine_code = jit(&program);
            let result = unsafe { run(&machine_code) };

            assert_eq!(result, expected, "Input program {program:?} doesn't work");
        }

        pair("+ + * - /", 1);
        pair("+ + * * * * * * * +", 257);
        pair("- * * - /", -2);
        pair("+++/*", 2);
        pair("+[>,[->++<]>.[-]<<]", 1);
    }
}
